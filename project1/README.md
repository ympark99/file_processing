# project1 : 파일 I/O 연산 프로그램 구현
- 파일의 데이터는 아라비아 숫자와 영어 알파벳만으로 표현되며, 터미널 상에서 사용자 입력으로 주어지는 데이터도 이 조건을 따른다.
- 파일 I/O 연산은 system call 또는 C 라이브러리만을 사용한다.

## (1) 복사: copy.c 작성
- 이미 존재하는 원본파일로부터 10바이트 단위로 데이터를 읽어 새로운 복사본파일에 저장한다. 
- 마지막으로 복사할 데이터가 10바이트가 되지 않는 경우 그 크기의 데이터를 읽어 복사본파일에 저장한다. 
- 명령어를 수행시킬 때 복사본파일은 존재하지 않으며 따라서 새로 생성해야 하며, 명령어를 실행한 후 복사본파일의 내용은 항상 원본파일의 것과 동일해야 한다.
    
- ### a.out <원본파일명> <복사본파일명>

## (2) 읽기: read.c 작성
- 이미 존재하는 파일에서 <오프셋(offset= 0, 1, 2, ...)>을 기준으로 왼쪽편 또는 오른쪽편에 존재하는 <바이트 수>의 절대값에 해당하는 크기만큼의 데이터를 읽어서 화면에 출력한다. 
- 만약 <바이트 수>가 양수이면 오른쪽편의 데이터를, 음수이면 왼쪽편의 데이터를 읽는다. 
- <바이트 수>가 0이면 데이터를 읽을 필요가 없으며 당연히 화면에 출력되는 데이터도 존재하지 않는다. 
- <바이트 수>의 절대값만큼의 데이터가 왼쪽 또는 오른쪽에 존재하지 않으면 존재하는 데이터만 읽으면 된다. 
- ex) <오프셋>이 10이고 <바이트 수>가 -5이면 오프셋 5부터 9까지 데이터를 읽어서 출력한다.

- ### a.out <오프셋> <바이트 수> <파일명>

## (3) 병합하기(merge): merge.c 작성
- 이미 존재하는 두 개의 파일, <파일1>과 <파일2>의 데이터를 병합한 새로운 파일 <파일3>을 생성한다. 
- 병합은 <파일1>과 <파일2>의 순서를 따르며, <파일3>의 크기는 입력된 두 개의 파일의 크기의 합과 정확히 일치해야 한다.

- ### a.out <파일명1> <파일명2> <파일명3>

## (4) 덮어쓰기(overwrite): overwrite.c 작성
- 이미 존재하는 파일에서 주어진 <오프셋(=0, 1, 2, ...)>에서부터 <데이터>를 덮어쓴다. 
- 덮어쓰기를 할 때 파일의 EOF를 만나면 중단하지 않고 그대로 쓰기를 진행한다. 
- <데이터>는 큰따옴표(“와 ”)로 묶어서 표현한다. (“abc”라고 입력하면 abc가 덮어쓸 데이터를 의미한다).

- ### a.out <오프셋> <데이터> <파일명>

## (5) 끼워넣기(insert): insert.c 작성
- 이미 존재하는 파일에서 <오프셋(=0, 1, 2, ...)>과 <오프셋+1> 사이에 <데이터>를 끼워 넣는다. 
- <오프셋>이 파일의 맨마지막(EOF제외)을 가리키면 append로 처리한다. 
- <데이터>는 큰따옴표(“와 ”)로 묶어서 표현한다 (“abc”라고 입력하면 abc가 끼워넣을 데이터를 의미한다).

- ### a.out <오프셋> <데이터> <파일명>

## (6) 삭제하기(delete): delete.c 작성
- 이미 존재하는 파일에서 <오프셋(offset= 0, 1, 2, ...)>을 기준으로 왼쪽편 또는 오른쪽편에 존재하는 <바이트 수>의 절대값에 해당하는 크기의 데이터를 삭제한다. 
- 만약 <바이트 수>가 양수이면 오른쪽편의 데이터를, 음수이면 왼쪽편의 데이터를 삭제한다. 
- <바이트 수>가 0이면 데이터를 삭제할 필요가 없다. 
- <바이트 수>의 절대값만큼의 데이터가 왼쪽 또는 오른쪽에 존재하지 않으면 존재하는 데이터만 삭제하면 된다. 
- ex) <오프셋>이 10이고 <바이트 수>가 -5이면 오프셋 5부터 9까지 데이터를 삭제한다. 삭제 후 삭제 데이터를 기준으로 전후 데이터가 병합되어야 한다. 즉, 삭제 데이터만큼의 공간은 파일에서 사라져야 한다.

- ### a.out <오프셋> <바이트 수> <파일명>
